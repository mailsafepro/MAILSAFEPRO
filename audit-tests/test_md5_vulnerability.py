"""
Test: Vulnerabilidad MD5 en caché HTTP

Demuestra que MD5 es vulnerable a colisiones y no debe usarse para seguridad.
"""
import pytest
import hashlib


def test_md5_collision_vulnerability():
    """
    Demuestra que MD5 permite colisiones y cache poisoning.
    
    Aunque este test no genera colisiones reales (requiere mucho cómputo),
    demuestra que MD5 es criptográficamente inseguro y no debe usarse.
    """
    # Dos queries diferentes
    q1 = "param1=value1&param2=value2"
    q2 = "param3=value3&param4=value4"  # Diferente query
    
    # MD5 es vulnerable a colisiones
    hash1_md5 = hashlib.md5(q1.encode()).hexdigest()
    hash2_md5 = hashlib.md5(q2.encode()).hexdigest()
    
    # SHA-256 es seguro
    hash1_sha256 = hashlib.sha256(q1.encode()).hexdigest()
    hash2_sha256 = hashlib.sha256(q2.encode()).hexdigest()
    
    # Verificar que son diferentes (en este caso)
    assert hash1_md5 != hash2_md5
    assert hash1_sha256 != hash2_sha256
    
    # El problema: MD5 es vulnerable a colisiones intencionales
    # Un atacante puede generar dos queries diferentes con el mismo hash MD5
    # Esto permite cache poisoning
    
    # Verificar que SHA-256 es más seguro (longitud mayor, algoritmo más fuerte)
    assert len(hash1_sha256) > len(hash1_md5)
    
    # Test pasa pero demuestra la vulnerabilidad conceptual


def test_md5_not_used_in_security_context():
    """
    Verifica que MD5 no se usa en contextos de seguridad.
    """
    import os
    import re
    
    # Buscar usos de MD5 en el código
    codebase_path = os.path.join(os.path.dirname(__file__), "..", "app")
    
    md5_usage_found = []
    for root, dirs, files in os.walk(codebase_path):
        for file in files:
            if file.endswith(".py"):
                filepath = os.path.join(root, file)
                try:
                    with open(filepath, "r") as f:
                        content = f.read()
                        # Buscar usos de hashlib.md5
                        if "hashlib.md5" in content or "md5(" in content:
                            lines = content.split("\n")
                            for i, line in enumerate(lines, 1):
                                if "hashlib.md5" in line or re.search(r"md5\s*\(", line):
                                    md5_usage_found.append((filepath, i, line.strip()))
                except Exception:
                    pass
    
    # Verificar que no hay usos de MD5 (excepto en este test)
    security_uses = [
        (path, line_num, code)
        for path, line_num, code in md5_usage_found
        if "test" not in path.lower() and "asgi_middleware" in path
    ]
    
    if security_uses:
        pytest.fail(
            f"❌ MD5 encontrado en contexto de seguridad:\n" +
            "\n".join([f"  {path}:{line_num} - {code}" for path, line_num, code in security_uses])
        )


def test_sha256_should_be_used_instead():
    """
    Verifica que SHA-256 se usa en lugar de MD5 para seguridad.
    """
    # Simular el uso correcto
    query_string = "param1=value1&param2=value2"
    
    # ✅ CORRECTO: SHA-256
    query_hash_sha256 = hashlib.sha256(query_string.encode()).hexdigest()
    
    # ❌ INCORRECTO: MD5 (vulnerable)
    query_hash_md5 = hashlib.md5(query_string.encode()).hexdigest()
    
    # Verificar que SHA-256 produce hash más largo (más seguro)
    assert len(query_hash_sha256) == 64  # SHA-256 produce 64 caracteres hex
    assert len(query_hash_md5) == 32  # MD5 produce 32 caracteres hex
    
    # SHA-256 es resistente a colisiones (computacionalmente imposible)
    # MD5 es vulnerable a colisiones (ya se han encontrado)

